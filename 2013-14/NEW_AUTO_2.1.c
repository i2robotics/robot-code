#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     IR_SEEK,        sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     WRIST,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     ARM,           tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     DRIVE_NW,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     DRIVE_NE,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     DRIVE_SE,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     DRIVE_SW,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_1,     FLAG,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     LIFT,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    FLAG_ROT,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    BLK_DROP,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    AUTO_BLK,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an Tetrix robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "./nav_2.00.h"  //Our
#include "./scaleJoy.h"  //Our own code to scale joystick values.
#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-light.h"

//#include "./ultra_1.00.h"
//#include "./movement.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
////////////////////////////////////////////////////////////////////////////////////////////////////
int choiceArray[] = {0, 0, 0};
int delay = 3;
short coolVal=0;
int coolVal2;
short encoderVal;
const tMUXSensor LEGOLS = msensor_S3_1;
const tMUXSensor LEGOLS2 = msensor_S3_2;
int turnSpeed = 23;

bool onWhite(int value) {
	if (value > 33) {
		return true;
	}
	return false;
}

bool onGrey(int value) {
	if (value < 27) {
		return true;
	}
	return false;
}

bool onGreyWhite(int value) {
	if (value > 27 && value < 33) {
		return true;
	}
	return false;
}

void endPgm() {
	halt();
	while (true) {}
}

void lineUp() {
	if (onGrey(LSvalNorm(LEGOLS))){
			while ((onGrey(LSvalNorm(LEGOLS))|| onWhite(LSvalNorm(LEGOLS))) || (onGrey(LSvalNorm(LEGOLS2)) || onWhite(LSvalNorm(LEGOLS2)))) {
				halt();
				while (onGrey(LSvalNorm(LEGOLS)) || onWhite(LSvalNorm(LEGOLS))) {
					if (onGrey(LSvalNorm(LEGOLS))){
						motor[DRIVE_NE] = -turnSpeed;
						motor[DRIVE_NW] = turnSpeed;
						motor[DRIVE_SW] = turnSpeed;
					}
					else{
						motor[DRIVE_NE] = turnSpeed;
						motor[DRIVE_NW] = -turnSpeed;
						motor[DRIVE_SW] = -turnSpeed;
					}
				}
				halt();
				while (onGrey(LSvalNorm(LEGOLS2)) || onWhite(LSvalNorm(LEGOLS2))) {
					if (onGrey(LSvalNorm(LEGOLS2))){
						motor[DRIVE_SE] = turnSpeed;
						motor[DRIVE_SW] = -turnSpeed;
						motor[DRIVE_NW] = -turnSpeed;
					}
					else{
						motor[DRIVE_SE] = -turnSpeed;
						motor[DRIVE_SW] = turnSpeed;
						motor[DRIVE_NW] = turnSpeed;
					}
				}
			}
		}
		else if (onGrey(LSvalNorm(LEGOLS2))){
			while ((onGrey(LSvalNorm(LEGOLS))|| onWhite(LSvalNorm(LEGOLS))) || (onGrey(LSvalNorm(LEGOLS2)) || onWhite(LSvalNorm(LEGOLS2)))) {
				halt();
				while (onGrey(LSvalNorm(LEGOLS2)) || onWhite(LSvalNorm(LEGOLS2))) {
					if (onGrey(LSvalNorm(LEGOLS2))){
						motor[DRIVE_SE] = turnSpeed;
						motor[DRIVE_SW] = -turnSpeed;
						motor[DRIVE_NW] = -turnSpeed;
					}
					else{
						motor[DRIVE_SE] = -turnSpeed;
						motor[DRIVE_SW] = turnSpeed;
						motor[DRIVE_NW] = turnSpeed;
					}
				}
				halt();
				while (onGrey(LSvalNorm(LEGOLS)) || onWhite(LSvalNorm(LEGOLS))) {
					if (onGrey(LSvalNorm(LEGOLS))){
						motor[DRIVE_NE] = -turnSpeed;
						motor[DRIVE_NW] = turnSpeed;
						motor[DRIVE_SW] = turnSpeed;
					}
					else{
						motor[DRIVE_NE] = turnSpeed;
						motor[DRIVE_NW] = -turnSpeed;
						motor[DRIVE_SW] = -turnSpeed;
					}
				}
			}
		}
}

void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	servo[AUTO_BLK]=255;
	servo[FLAG_ROT]=0;
	int selected = 0;
	ClearTimer(T1);
	const char *startChoices[] = {"Left","Right"};
	const char *endChoices[] = {"Left","Right"};
	const char *bridgeChoices[] = {"Close","Far","No"};
	while (true) {
		eraseDisplay();
		nxtDisplayStringAt(15, 62, "Start:");
		nxtDisplayStringAt(15, 52, "End:");
		nxtDisplayStringAt(15, 42, "Bridge:");
		nxtDisplayStringAt(15, 32, "Delay:");
		nxtDrawLine (0, 22, 100, 22);
		nxtDisplayStringAt(5, 18, "Ext Batt: %.2f", ((float) externalBatteryAvg)/1000);
		nxtDisplayStringAt(5, 8, "NXT Batt: %.2f", ((float) nAvgBatteryLevel)/1000);

		nxtDisplayStringAt(55, 62, "%s", startChoices[choiceArray[0]]);
		nxtDisplayStringAt(43, 52, "%s", endChoices[choiceArray[1]]);
		nxtDisplayStringAt(59, 42, "%s", bridgeChoices[choiceArray[2]]);
		nxtDisplayStringAt(55, 32, "%d", delay);
		//sizeof(startChoices) / sizeof(startChoices[0]);
		nxtDisplayStringAt(5, 62 -selected*10, "*");

		if (nNxtButtonPressed == 1) {
			if (time10[T1]>30) {
				switch (selected) {
					case 0:
						if (choiceArray[0]==1) {
							choiceArray[0] = 0;
						}
						else {
							choiceArray[0]++;
						}
						break;
					case 1:
						if (choiceArray[1]==1) {
							choiceArray[1] = 0;
						}
						else {
							choiceArray[1]++;
						}
						break;
					case 2:
						if (choiceArray[2]==2) {
							choiceArray[2] = 0;
						}
						else {
							choiceArray[2]++;
						}
						break;
					case 3:
						if (delay < 20){
							delay++;
						}
						else {
							delay = 0;
						}
						break;
				}
				ClearTimer(T1);
			}
		}
		if (nNxtButtonPressed == 2) {
			if (time10[T1]>30) {
				if (selected == 3) {
  				selected = 0;
  			}
  			else {
  				selected++;
  			}
  			ClearTimer(T1);
  		}
		}
		if (nNxtButtonPressed == 3) {
			break;
		}


		wait10Msec(2);
	}
	LSsetActive(LEGOLS);
	LSsetActive(LEGOLS2);
	return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int speed = 50;

task main()
{
	initializeRobot();
	//waitForStart();
	servo[AUTO_BLK]=255;
	nMotorEncoder[DRIVE_NW] = 0;
	wait10Msec(delay*100);
	ClearTimer(T1);

	if (choiceArray[0]==1) {
		while (SensorValue[IR_SEEK]!=5) {
			if (SensorValue[IR_SEEK]>5) {
				drive(S,speed,0);
			}
			else {
				drive(N,speed,0);
			}
		}

		drive(S,20,175);
		wait10Msec(10);
 		coolVal2 = nMotorEncoder[DRIVE_NW];
		//while (nMotorEncoder[DRIVE_NW] - coolVal2> -200) {
		//	drive(S,20,0);
		//}
		if (nMotorEncoder[DRIVE_NW]>4500) {
			coolVal2 = nMotorEncoder[DRIVE_NW];
			while (nMotorEncoder[DRIVE_NW] - coolVal2> -250) {
				drive(S,20,0);
			}
		}
		servoChangeRate[AUTO_BLK]=8;

		halt();

		servo[AUTO_BLK]=0;
		wait10Msec(85);
		servoChangeRate[AUTO_BLK]=10;
		servo[AUTO_BLK]=255;
		wait10Msec(40);

		encoderVal=nMotorEncoder[DRIVE_NW];

		nMotorEncoder[DRIVE_NW] = 0;
	}
	else if (choiceArray[0]==0) {
		nMotorEncoder[DRIVE_NW]=0;

		while (SensorValue[IR_SEEK]!=5) {
			if (SensorValue[IR_SEEK]>5 || SensorValue[IR_SEEK]==0) {
				drive(S,speed,0);
			}
			else {
				drive(N,speed,0);
			}
		}

		drive(S,20,175);
 		coolVal2 = nMotorEncoder[DRIVE_NW];
		//while (nMotorEncoder[DRIVE_NW] - coolVal2> -200) {
		//	drive(S,20,0);
		//}
		//if (nMotorEncoder[DRIVE_NW]>-4500) {
		//	coolVal2 = nMotorEncoder[DRIVE_NW];
		//	while (nMotorEncoder[DRIVE_NW] - coolVal2> -200) {
		//		drive(S,20,0);
		//	}
		//}

		encoderVal=nMotorEncoder[DRIVE_NW];


		servoChangeRate[AUTO_BLK]=8;

		halt();

		servo[AUTO_BLK]=0;
		wait10Msec(85);
		servoChangeRate[AUTO_BLK]=10;
		servo[AUTO_BLK]=255;
		wait10Msec(40);

		nMotorEncoder[DRIVE_NW] = 0;
	}
	ClearTimer(T1);
	if (choiceArray[1]==0) {
		if (choiceArray[0]==1){
			coolVal = encoderVal;
			while (coolVal<7650) {
				drive(N,speed,0);
				coolVal = encoderVal + nMotorEncoder[DRIVE_NW];
				if (time1[T1]>4000) {
					endPgm();
				}
			}
		}
		else if (choiceArray[0]==0) {
			coolVal = encoderVal;
			while (coolVal<-1400) {
				drive(N,speed,0);
				coolVal = encoderVal + nMotorEncoder[DRIVE_NW];
				if (time1[T1]>4000) {
					endPgm();
				}
			}
		}

		if (choiceArray[2]==2) {
			motor[DRIVE_NW] = 90;
			motor[DRIVE_SE] = 90;
			motor[DRIVE_NE] = -22;
			motor[DRIVE_SW] = -22;
			wait1Msec(1750);
			halt();
			motor[DRIVE_NW] = 40;
			motor[DRIVE_SE] = 40;
			motor[DRIVE_NE] = -90;
			motor[DRIVE_SW] = -90;
			wait1Msec(1700);

			motor[DRIVE_NW] = 50;
			motor[DRIVE_SE] = -50;
			motor[DRIVE_NE] = -50;
			motor[DRIVE_SW] = 50;

			wait1Msec(225);


			nMotorEncoder[DRIVE_NW]=0;
			ClearTimer(T1);
			while(nMotorEncoder[DRIVE_NW]>-5750) {
				drive(S,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}
		else {
			LSsetActive(LEGOLS);
			LSsetActive(LEGOLS2);

			motor[DRIVE_NW] = 90;
			motor[DRIVE_SE] = 90;
			motor[DRIVE_NE] = -22;
			motor[DRIVE_SW] = -22;
			wait1Msec(700);
			ClearTimer(T1);
			while (onGrey(LSvalNorm(LEGOLS)) && onGrey(LSvalNorm(LEGOLS2))) {
				motor[DRIVE_NW] = 40;
				motor[DRIVE_SE] = 40;
				motor[DRIVE_NE] = -90;
				motor[DRIVE_SW] = -90;
				if (time1[T1]>4000) {
					endPgm();
				}
			}
			halt();

			lineUp();

			drive(E,80,150);
			drive(S,40,300);
			if (choiceArray[2]==1) {
				drive(E,80,150);
				while (onGrey(LSvalNorm(LEGOLS)) && onGrey(LSvalNorm(LEGOLS2))) {
					drive(E,50,0);
				}
				lineUp();
				drive(E,80,400);
				while (onGrey(LSvalNorm(LEGOLS)) && onGrey(LSvalNorm(LEGOLS2))) {
					drive(E,50,0);
				}

				lineUp();
				drive(W,80,200);
			}
			nMotorEncoder[DRIVE_NW]=0;
			ClearTimer(T1);
			while(nMotorEncoder[DRIVE_NW]>-5500) {
				drive(S,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}





	}
	else if (choiceArray[1]==1) {
		ClearTimer(T1);
		if (choiceArray[0]==1){
			coolVal = encoderVal;
			while (coolVal>1575) {
				drive(S,speed,0);
				coolVal = encoderVal + nMotorEncoder[DRIVE_NW];
				if (time1[T1]>4000) {
					endPgm();
				}
			}
		}
		else if (choiceArray[0]==0) {
			coolVal = encoderVal;
			while (coolVal>-7350) {
				drive(S,speed,0);
				coolVal = encoderVal + nMotorEncoder[DRIVE_NW];
				if (time1[T1]>4000) {
					endPgm();
				}
			}
		}

		if (choiceArray[2]==2) {

			motor[DRIVE_NW] = 12;
			motor[DRIVE_SE] = 12;
			motor[DRIVE_NE] = -90;
			motor[DRIVE_SW] = -90;
			wait1Msec(1250);
			halt();
			drive(E,50,2500);
			ClearTimer(T1);
			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<4500) {
				drive(N,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}
		else {
			LSsetActive(LEGOLS);
			LSsetActive(LEGOLS2);

			motor[DRIVE_NW] = 12;
			motor[DRIVE_SE] = 12;
			motor[DRIVE_NE] = -90;
			motor[DRIVE_SW] = -90;
			wait1Msec(1250);



			ClearTimer(T1);
			while (onGrey(LSvalNorm(LEGOLS)) && onGrey(LSvalNorm(LEGOLS2))) {
				drive(E,50,0);
				if (time1[T1]>4000) {
					endPgm();
				}
			}
			halt();

			lineUp();

			drive(E,80,150);
			drive(N,40,300);
			if (choiceArray[2]==1) {
				drive(E,80,150);
				while (onGrey(LSvalNorm(LEGOLS)) && onGrey(LSvalNorm(LEGOLS2))) {
					drive(E,50,0);
				}
				lineUp();
				drive(E,80,400);
				while (onGrey(LSvalNorm(LEGOLS)) && onGrey(LSvalNorm(LEGOLS2))) {
					drive(E,50,0);
				}

				lineUp();
				drive(W,80,200);
			}
			ClearTimer(T1);
			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<4000) {
				drive(N,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}
	}
	halt();


}
