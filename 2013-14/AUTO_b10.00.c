#pragma This should stop it from compiling. This is a major refactor in alpha, and shouldnt be used.
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     IR_SEEK,        sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     WRIST,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     ARM,           tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     DRIVE_NW,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     DRIVE_NE,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     DRIVE_SE,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     DRIVE_SW,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_1,     FLAG,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     LIFT,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    FLAG_ROT,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    BLK_DROP,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    AUTO_BLK,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define csfront   0
#define csback    1
#define csGray      1
#define csGrayWhite 2
#define csWhite     3
#define csGrayBlue  4
#define csBlue      5
#define csBlueRed   6
#define csGrayRed   7
#define csRed       8

#include "./headers/nav_3.h"
#include "./headers/scaleJoy_1.h"  //Our own code to scale joystick values.
#include "./headers/color_1.h"
#include "./headers/choose_1.h"

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-light.h"
#include "drivers/hitechnic-colour-v2.h"



short wheelEnc_2=0;
int wheelEnc_3;
short wheelEnc;
const tMUXSensor HTCOLOR1 = msensor_S3_1;
const tMUXSensor HTCOLOR2 = msensor_S3_2;
int turnSpeed = 23;
short turnOffset;



void endPgm() {
	halt();
	playImmediateTone(200,200);
	while (true) {}
}


void lineUp() {
	ClearTimer(T1);
	if (onGray(csfront)){
        while ( (onGray(csfront)|| onWhite(csfront))  ||  (onGray(csback) || onWhite(csback)) ) {
            halt();
            while (onGray(csfront) || onWhite(csfront)) {
                if (onGray(csfront)){
                    motor[DRIVE_NE] = -turnSpeed;
                    motor[DRIVE_NW] = turnSpeed;
                    motor[DRIVE_SW] = turnSpeed;
                }
                else{
                    motor[DRIVE_NE] = turnSpeed;
                    motor[DRIVE_NW] = -turnSpeed;
                    motor[DRIVE_SW] = -turnSpeed;
                }
                if (time1[T1]>5000) {
                    endPgm();
                }
            }
            halt();
            while (onGray(csback) || onWhite(csback)) {
                if (onGray(csback)){
                    motor[DRIVE_SE] = turnSpeed;
                    motor[DRIVE_SW] = -turnSpeed;
                    motor[DRIVE_NW] = -turnSpeed;
                }
                else{
                    motor[DRIVE_SE] = -turnSpeed;
                    motor[DRIVE_SW] = turnSpeed;
                    motor[DRIVE_NW] = turnSpeed;
                }
                if (time1[T1]>5000) {
                    endPgm();
                }
            }
        }
    }
    else if (onGray(csback)){
        while ((onGray(csfront)|| onWhite(csfront)) || (onGray(csback) || onWhite(csback))) {
            halt();
            while (onGray(csback) || onWhite(csback)) {
                if (onGray(csback)){
                    motor[DRIVE_SE] = turnSpeed;
                    motor[DRIVE_SW] = -turnSpeed;
                    motor[DRIVE_NW] = -turnSpeed;
                }
                else{
                    motor[DRIVE_SE] = -turnSpeed;
                    motor[DRIVE_SW] = turnSpeed;
                    motor[DRIVE_NW] = turnSpeed;
                }
                if (time1[T1]>5000) {
                    endPgm();
                }
            }
            halt();
            while (onGray(csfront) || onWhite(csfront)) {
                if (onGray(csfront)){
                    motor[DRIVE_NE] = -turnSpeed;
                    motor[DRIVE_NW] = turnSpeed;
                    motor[DRIVE_SW] = turnSpeed;
                }
                else{
                    motor[DRIVE_NE] = turnSpeed;
                    motor[DRIVE_NW] = -turnSpeed;
                    motor[DRIVE_SW] = -turnSpeed;
                }
                if (time1[T1]>5000) {
                    endPgm();
                }
            }
        }
    }
}

void initializeRobot()
{
	servo[AUTO_BLK]=255;
	servo[FLAG_ROT]=0;

	choose_auto_opts();

}


int speed = 50;

task main()
{
	initializeRobot();
	//waitForStart(); // The almighty WAIT FOR START!!!

	servo[AUTO_BLK]=255;
	nMotorEncoder[DRIVE_NW] = 0;
	wait1Msec(startDelay * 1000);
	ClearTimer(T1);//reset internal timer `T1`

	if (choiceArray[0]==1) { // if start == 1 = right
        nMotorEncoder[DRIVE_NW]=0;

		while (SensorValue[IR_SEEK]!=5) {
			if (SensorValue[IR_SEEK]>5) {
				drive(S,speed,0);
			}
			else {
				drive(N,speed,0);
			}
		}

		wait1Msec(100);

 		wheelEnc_3 = nMotorEncoder[DRIVE_NW];

		if (nMotorEncoder[DRIVE_NW] > 4500) {
			wheelEnc_3 = nMotorEncoder[DRIVE_NW];
			while ((nMotorEncoder[DRIVE_NW] - wheelEnc_3) > -365) {
				drive(S,20,0);
			}
		}
		else {
			while (nMotorEncoder[DRIVE_NW] - wheelEnc_3> -83) {
				drive(S,20,0);
			}
		}

    	wheelEnc=nMotorEncoder[DRIVE_NW];

		servoChangeRate[AUTO_BLK]=8;

		halt();

		servo[AUTO_BLK]=0;
		wait10Msec(85);
		servoChangeRate[AUTO_BLK]=10;
		servo[AUTO_BLK]=255;
		wait10Msec(40);


		nMotorEncoder[DRIVE_NW] = 0;
	}
	else if (choiceArray[0]==0) { //if start == 0
		nMotorEncoder[DRIVE_NW]=0;

		while (SensorValue[IR_SEEK]!=5) {
			if (SensorValue[IR_SEEK]>5 || SensorValue[IR_SEEK]==0) {
				drive(S,speed,0);
			}
			else {
				drive(N,speed,0);
			}
		}

		drive(S,20,175);
 		wheelEnc_3 = nMotorEncoder[DRIVE_NW];
		//while (nMotorEncoder[DRIVE_NW] - wheelEnc_3> -200) {
		//	drive(S,20,0);
		//}
		if (nMotorEncoder[DRIVE_NW] < -4500) {
			wheelEnc_3 = nMotorEncoder[DRIVE_NW];
			while ((nMotorEncoder[DRIVE_NW] - wheelEnc_3) < 200) {
				drive(N,30,0);
			}
		}

		servoChangeRate[AUTO_BLK]=8;

		halt();
    	wheelEnc = nMotorEncoder[DRIVE_NW];//set wheelEnc
    	nMotorEncoder[DRIVE_NW] = 0;			//before resetting it

		servo[AUTO_BLK]=0;
		wait10Msec(85);
		servoChangeRate[AUTO_BLK]=10;
		servo[AUTO_BLK]=255;
		wait10Msec(40);

	}// </start>


	ClearTimer(T1);
	if (choiceArray[1]==0) { //if end == left 0
		if (choiceArray[0]==1){ // if started right
			wheelEnc_2 = wheelEnc; //wheelEnc as at the end of start
			while (wheelEnc_2 < 7650) {
				drive(N,speed,0);
				wheelEnc_2 = wheelEnc + nMotorEncoder[DRIVE_NW];//= encVal at end of start + since this while started
				if (time1[T1]>4000) { //safety
					endPgm();
				}
			}
			halt();
		}
		else if (choiceArray[0]==0) { //if started left
			wheelEnc_2 = wheelEnc;//wheelEnc as at the end of start
			while (wheelEnc_2<-1000) {
				drive(N,speed,0);
				wheelEnc_2 = wheelEnc + nMotorEncoder[DRIVE_NW];//= encVal at end of start + since this while started
				if (time1[T1]>4000) {
					endPgm(); //safety
				}
			}
		}

		if (choiceArray[2]==2) { //if bridge == no light sensors
		nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<2050){
				motor[DRIVE_NE]=-100;
				motor[DRIVE_NW]=100;
				motor[DRIVE_SE]=-100;
				motor[DRIVE_SW]=100;
			}
			halt();

			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<4500){
				motor[DRIVE_NE]=100;
				motor[DRIVE_NW]=100;
				motor[DRIVE_SE]=100;
				motor[DRIVE_SW]=100;
			}
			halt();

			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]>-1450){
				motor[DRIVE_NE]=100;
				motor[DRIVE_NW]=-100;
				motor[DRIVE_SE]=100;
				motor[DRIVE_SW]=-100;
			}
			halt();


			nMotorEncoder[DRIVE_NW]=0;
			ClearTimer(T1);
			while(nMotorEncoder[DRIVE_NW] > -6550) {
				drive(S,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}
		else { //if bridge != none

			turnOffset=nMotorEncoder[DRIVE_NW];
			while(nMotorEncoder[DRIVE_NW]-turnOffset<2050){
				motor[DRIVE_NE]=-100;
				motor[DRIVE_NW]=100;
				motor[DRIVE_SE]=-100;
				motor[DRIVE_SW]=100;
			}
			halt();
			wait1Msec(2300);
			turnOffset=nMotorEncoder[DRIVE_NW];
			while(nMotorEncoder[DRIVE_NW]-turnOffset<2500){
				motor[DRIVE_NE]=100;
				motor[DRIVE_NW]=100;
				motor[DRIVE_SE]=100;
				motor[DRIVE_SW]=100;
			}
			halt();
			wait1Msec(1300);
			turnOffset=nMotorEncoder[DRIVE_NW];
			while(nMotorEncoder[DRIVE_NW]-turnOffset>-1900){
				motor[DRIVE_NE]=100;
				motor[DRIVE_NW]=-100;
				motor[DRIVE_SE]=100;
				motor[DRIVE_SW]=-100;
			}
			halt();

			ClearTimer(T1);
			while (onGray(csfront) && onGray(csback)) { //!!
				motor[DRIVE_NW] = 40;
				motor[DRIVE_SE] = 40;
				motor[DRIVE_NE] = -90;
				motor[DRIVE_SW] = -90;
				if (time1[T1]>4000) {
					endPgm();
				}
			}
			halt();

			lineUp();

			drive(E,80,150);
			drive(S,40,300);
			if (choiceArray[2]==1) {// if bridge == far
				drive(E,80,150);
				while (onGray(csfront) && onGray(csback)) {
					drive(E,50,0);
				}
				lineUp();
				drive(E,80,400);
				while (onGray(csfront) && onGray(csback)) {
					drive(E,50,0);
				}

				lineUp();
				drive(W,80,200);
			}
			nMotorEncoder[DRIVE_NW]=0;
			ClearTimer(T1);
			while(nMotorEncoder[DRIVE_NW]>-5500) {
				drive(S,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}


	}
	else if (choiceArray[1]==1) {// if end == right
		ClearTimer(T1);
		if (choiceArray[0]==1){// if started right
			wheelEnc_2 = wheelEnc;//wheelEnc as at the end of start
			while (wheelEnc_2>1025) {
				drive(S,speed,0);
				wheelEnc_2 = wheelEnc + nMotorEncoder[DRIVE_NW];//= encVal at end of start + since this while started
				if (time1[T1]>4000) {//safety
					endPgm();
				}
			}
		}
		else if (choiceArray[0]==0) {// if started left
			wheelEnc_2 = wheelEnc;//wheelEnc as at the end of start
			while (wheelEnc_2>-7650) {
				drive(S,speed,0);
				wheelEnc_2 = wheelEnc + nMotorEncoder[DRIVE_NW];//= encVal at end of start + since this while started
				if (time1[T1]>4000) {
					endPgm();//safety
				}
			}
		}

		if (choiceArray[2]==2) {// if bridge == none
			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]>-1800){
				motor[DRIVE_NE]=100;
				motor[DRIVE_NW]=-100;
				motor[DRIVE_SE]=100;
				motor[DRIVE_SW]=-100;
			}
			halt();

			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]>-4500){
				motor[DRIVE_NE]=-100;
				motor[DRIVE_NW]=-100;
				motor[DRIVE_SE]=-100;
				motor[DRIVE_SW]=-100;
			}
			halt();

			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<1200){
				motor[DRIVE_NE]=-100;
				motor[DRIVE_NW]=100;
				motor[DRIVE_SE]=-100;
				motor[DRIVE_SW]=100;
			}
			halt();

			ClearTimer(T1);
			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<4500) {
				drive(N,100,0);
				if (time1[T1]>5000) {
					endPgm();//safety
				}
			}
		}
		else {//if bridge != none

			motor[DRIVE_NW] = 12;
			motor[DRIVE_SE] = 12;
			motor[DRIVE_NE] = -90;
			motor[DRIVE_SW] = -90;
			wait1Msec(1550);

			ClearTimer(T1);
			while (onGray(csfront) && onGray(csback)) {//!!
				drive(E,50,0);
				if (time1[T1]>4000) {
					endPgm();
				}
			}
			halt();

			lineUp();

			drive(E,80,150);
			drive(N,40,300);
			if (choiceArray[2]==1) {// if bridge == far
				drive(E,80,150);
				while (onGray(csfront) && onGray(csback)) {
					drive(E,50,0);
				}
				lineUp();
				drive(E,80,400);
				while (onGray(csfront) && onGray(csback)) {
					drive(E,50,0);
				}

				lineUp();
				drive(W,80,200);
			}
			ClearTimer(T1);
			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<4000) {
				drive(N,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}
	}
	halt();
    while (true) {}

}
