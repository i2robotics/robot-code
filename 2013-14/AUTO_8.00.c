#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     IR_SEEK,        sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     WRIST,         tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     ARM,           tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     DRIVE_NW,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     DRIVE_NE,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     DRIVE_SE,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     DRIVE_SW,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_1,     FLAG,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     LIFT,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    FLAG_ROT,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    BLK_DROP,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    AUTO_BLK,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define csfront 0
#define csback 1
#define csGray 1
#define csGrayWhite 2
#define csWhite 3
#define csGrayBlue 4
#define csBlue 5
#define csBlueRed 6
#define csGrayRed 7
#define csRed 8

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an Tetrix robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "./nav_2.00.h"  //Our
#include "./scaleJoy.h"  //Our own code to scale joystick values.
#include "drivers/hitechnic-sensormux.h"
#include "drivers/lego-light.h"
#include "drivers/hitechnic-colour-v2.h"

//#include "./ultra_1.00.h"
//#include "./movement.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
////////////////////////////////////////////////////////////////////////////////////////////////////
int choiceArray[] = {1, 1, 2};
int delay = 3;
short coolVal=0;
int coolVal2;
short encoderVal;
const tMUXSensor HTCOLOR1 = msensor_S3_1;
const tMUXSensor HTCOLOR2 = msensor_S3_2;
int turnSpeed = 23;

int red = 0;
int green = 0;
int blue = 0;

int color(int value) {
	if (value==0) {
		HTCS2readRGB(HTCOLOR1, red, green, blue);
	}
	else if (value==1) {
		HTCS2readRGB(HTCOLOR2, red, green, blue);
	}
	if (red<27 && green<27 && blue < 23) {
		return 1;
	}
	else if (red < 120 && red > 100 && green < 120 && green > 100 && blue > 90 && blue < 110) {
		return 2;
	}
	else if (red > 170 && green > 175 && blue > 155) {
		return 3;
	}
	else if (red  < 25 && green > 25 && green < 40 && blue < 60 && blue > 50) {
		return 4;
	}
	else if (red < 25 && green > 33 && green < 45 && blue > 70 && blue < 85) {
		return 5;
	}
	else if (red > 53 && red < 68 && green < 35 && green > 20 && blue > 30 && blue < 43) {
		return 6;
	}
	else if (red > 50 && red < 62 && green > 15 && green < 25 && blue <20) {
		return 7;
	}
	else if (red > 90 && red < 110 && green <25 && blue < 10) {
		return 8;
	}
	return 1;
}

bool onWhite(int value) {
	if (color(value) == csWhite) {
		return true;
	}
	return false;
}

bool onGrey(int value) {
	if (color(value) == csGray) {
		return true;
	}
	return false;
}

bool onGreyWhite(int value) {
	if (color(value) == csGrayWhite) {
		return true;
	}
	return false;
}

void endPgm() {
	halt();
	while (true) {}
}


void lineUp() {
	ClearTimer(T1);
	if (onGrey(csfront)){
			while ((onGrey(csfront)|| onWhite(csfront)) || (onGrey(csback) || onWhite(csback))) {
				halt();
				while (onGrey(csfront) || onWhite(csfront)) {
					if (onGrey(csfront)){
						motor[DRIVE_NE] = -turnSpeed;
						motor[DRIVE_NW] = turnSpeed;
						motor[DRIVE_SW] = turnSpeed;
					}
					else{
						motor[DRIVE_NE] = turnSpeed;
						motor[DRIVE_NW] = -turnSpeed;
						motor[DRIVE_SW] = -turnSpeed;
					}
					if (time1[T1]>5000) {
						endPgm();
					}
				}
				halt();
				while (onGrey(csback) || onWhite(csback)) {
					if (onGrey(csback)){
						motor[DRIVE_SE] = turnSpeed;
						motor[DRIVE_SW] = -turnSpeed;
						motor[DRIVE_NW] = -turnSpeed;
					}
					else{
						motor[DRIVE_SE] = -turnSpeed;
						motor[DRIVE_SW] = turnSpeed;
						motor[DRIVE_NW] = turnSpeed;
					}
					if (time1[T1]>5000) {
						endPgm();
					}
				}
			}
		}
		else if (onGrey(csback)){
			while ((onGrey(csfront)|| onWhite(csfront)) || (onGrey(csback) || onWhite(csback))) {
				halt();
				while (onGrey(csback) || onWhite(csback)) {
					if (onGrey(csback)){
						motor[DRIVE_SE] = turnSpeed;
						motor[DRIVE_SW] = -turnSpeed;
						motor[DRIVE_NW] = -turnSpeed;
					}
					else{
						motor[DRIVE_SE] = -turnSpeed;
						motor[DRIVE_SW] = turnSpeed;
						motor[DRIVE_NW] = turnSpeed;
					}
					if (time1[T1]>5000) {
						endPgm();
					}
				}
				halt();
				while (onGrey(csfront) || onWhite(csfront)) {
					if (onGrey(csfront)){
						motor[DRIVE_NE] = -turnSpeed;
						motor[DRIVE_NW] = turnSpeed;
						motor[DRIVE_SW] = turnSpeed;
					}
					else{
						motor[DRIVE_NE] = turnSpeed;
						motor[DRIVE_NW] = -turnSpeed;
						motor[DRIVE_SW] = -turnSpeed;
					}
					if (time1[T1]>5000) {
						endPgm();
					}
				}
			}
		}
}

void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	servo[AUTO_BLK]=255;
	servo[FLAG_ROT]=0;
	int selected = 0;
	ClearTimer(T1);
	const char *startChoices[] = {"Left","Right"};
	const char *endChoices[] = {"Left","Right"};
	const char *bridgeChoices[] = {"Close","Far","No"};
	while (true) {
		eraseDisplay();
		nxtDisplayStringAt(15, 62, "Start:");
		nxtDisplayStringAt(15, 52, "End:");
		nxtDisplayStringAt(15, 42, "Bridge:");
		nxtDisplayStringAt(15, 32, "Delay:");
		nxtDrawLine (0, 22, 100, 22);
		nxtDisplayStringAt(5, 18, "Ext Batt: %.2f", ((float) externalBatteryAvg)/1000);
		nxtDisplayStringAt(5, 8, "NXT Batt: %.2f", ((float) nAvgBatteryLevel)/1000);

		nxtDisplayStringAt(55, 62, "%s", startChoices[choiceArray[0]]);
		nxtDisplayStringAt(43, 52, "%s", endChoices[choiceArray[1]]);
		nxtDisplayStringAt(59, 42, "%s", bridgeChoices[choiceArray[2]]);
		nxtDisplayStringAt(55, 32, "%d", delay);
		//sizeof(startChoices) / sizeof(startChoices[0]);
		nxtDisplayStringAt(5, 62 -selected*10, "*");

		if (nNxtButtonPressed == 1) {//button press right
			if (time10[T1]>30) {
				switch (selected) {
					case 0:
						if (choiceArray[0]==1) {
							choiceArray[0] = 0;
						}
						else {
							choiceArray[0]++;
						}
						break;
					case 1:
						if (choiceArray[1]==1) {
							choiceArray[1] = 0;
						}
						else {
							choiceArray[1]++;
						}
						break;
					case 2:
						if (choiceArray[2]==2) {
							choiceArray[2] = 0;
						}
						else {
							choiceArray[2]++;
						}
						break;
					case 3:
						if (delay < 20){
							delay++;
						}
						else {
							delay = 0;
						}
						break;
				}
				ClearTimer(T1);
			}
		}
		if (nNxtButtonPressed == 2) {// on button press Left
			if (time10[T1]>30) {
				if (selected == 3) {
  				selected = 0;
  			}
  			else {
  				selected++;             //increment selected
  			}
  			ClearTimer(T1);
  		}
		}
		if (nNxtButtonPressed == 3) { // button orange
			break;
		}


		wait10Msec(2);
	}
	return;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

int speed = 50;
bool coolVar = false;
bool coolVar2 = false;

task main()
{
	initializeRobot();
	waitForStart();
	servo[AUTO_BLK]=255;
	nMotorEncoder[DRIVE_NW] = 0;
	wait10Msec(delay*100);
	ClearTimer(T1);

	if (choiceArray[0]==1) {
		while (SensorValue[IR_SEEK]!=5) {
			if (SensorValue[IR_SEEK]>5) {
				drive(S,speed,0);
			}
			else {
				drive(N,speed,0);
			}
		}

		wait10Msec(10);
 		coolVal2 = nMotorEncoder[DRIVE_NW];
		//while (nMotorEncoder[DRIVE_NW] - coolVal2> -200) {
		//	drive(S,20,0);
		//}
		if (nMotorEncoder[DRIVE_NW]>4500) {
			coolVal2 = nMotorEncoder[DRIVE_NW];
			while (nMotorEncoder[DRIVE_NW] - coolVal2> -365) {
				drive(S,20,0);
			}
		}
		else {
			while (nMotorEncoder[DRIVE_NW] - coolVal2> -83) {
				drive(S,20,0);
			}
		}

		servoChangeRate[AUTO_BLK]=8;

		halt();

		servo[AUTO_BLK]=0;
		wait10Msec(85);
		servoChangeRate[AUTO_BLK]=10;
		servo[AUTO_BLK]=255;
		wait10Msec(40);

		encoderVal=nMotorEncoder[DRIVE_NW];

		nMotorEncoder[DRIVE_NW] = 0;
	}
	else if (choiceArray[0]==0) {
		nMotorEncoder[DRIVE_NW]=0;

		while (SensorValue[IR_SEEK]!=5) {
			if (SensorValue[IR_SEEK]>5 || SensorValue[IR_SEEK]==0) {
				drive(S,speed,0);
			}
			else {
				drive(N,speed,0);
			}
		}

		drive(S,20,175);
 		coolVal2 = nMotorEncoder[DRIVE_NW];
		//while (nMotorEncoder[DRIVE_NW] - coolVal2> -200) {
		//	drive(S,20,0);
		//}
 		coolVar = true;
		if (nMotorEncoder[DRIVE_NW]<-4500) {
			coolVal2 = nMotorEncoder[DRIVE_NW];
			while (nMotorEncoder[DRIVE_NW] - coolVal2 < 200) {
				drive(N,30,0);
			}
		}

		encoderVal=nMotorEncoder[DRIVE_NW];


		servoChangeRate[AUTO_BLK]=8;

		halt();

		servo[AUTO_BLK]=0;
		wait10Msec(85);
		servoChangeRate[AUTO_BLK]=10;
		servo[AUTO_BLK]=255;
		wait10Msec(40);

		nMotorEncoder[DRIVE_NW] = 0;
	}
	ClearTimer(T1);
	if (choiceArray[1]==0) {
		if (choiceArray[0]==1){
			coolVal = encoderVal;
			while (coolVal<7650) {
				drive(N,speed,0);
				coolVal = encoderVal + nMotorEncoder[DRIVE_NW];
				if (time1[T1]>4000) {
					endPgm();
				}
			}
		}
		else if (choiceArray[0]==0) {
			coolVal = encoderVal;
			while (coolVal<-1000) {
				drive(N,speed,0);
				coolVal = encoderVal + nMotorEncoder[DRIVE_NW];
				if (time1[T1]>4000) {
					endPgm();
				}
			}
		}

		if (choiceArray[2]==2) {
			motor[DRIVE_NW] = 90;
			motor[DRIVE_SE] = 90;
			motor[DRIVE_NE] = -22;
			motor[DRIVE_SW] = -22;
			wait1Msec(1750);
			halt();
			motor[DRIVE_NW] = 40;
			motor[DRIVE_SE] = 40;
			motor[DRIVE_NE] = -90;
			motor[DRIVE_SW] = -90;
			wait1Msec(1700);

			motor[DRIVE_NW] = 50;
			motor[DRIVE_SE] = -50;
			motor[DRIVE_NE] = -50;
			motor[DRIVE_SW] = 50;

			wait1Msec(225);


			nMotorEncoder[DRIVE_NW]=0;
			ClearTimer(T1);
			while(nMotorEncoder[DRIVE_NW]>-5750) {
				drive(S,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}
		else {

			motor[DRIVE_NW] = 90;
			motor[DRIVE_SE] = 90;
			motor[DRIVE_NE] = -22;
			motor[DRIVE_SW] = -22;
			wait1Msec(1300);
			ClearTimer(T1);
			while (onGrey(csfront) && onGrey(csback)) {
				motor[DRIVE_NW] = 40;
				motor[DRIVE_SE] = 40;
				motor[DRIVE_NE] = -90;
				motor[DRIVE_SW] = -90;
				if (time1[T1]>4000) {
					endPgm();
				}
			}
			halt();

			lineUp();

			drive(E,80,150);
			drive(S,40,300);
			if (choiceArray[2]==1) {
				drive(E,80,150);
				while (onGrey(csfront) && onGrey(csback)) {
					drive(E,50,0);
				}
				lineUp();
				drive(E,80,400);
				while (onGrey(csfront) && onGrey(csback)) {
					drive(E,50,0);
				}

				lineUp();
				drive(W,80,200);
			}
			nMotorEncoder[DRIVE_NW]=0;
			ClearTimer(T1);
			while(nMotorEncoder[DRIVE_NW]>-5500) {
				drive(S,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}





	}
	else if (choiceArray[1]==1) {
		ClearTimer(T1);
		if (choiceArray[0]==1){
			coolVal = encoderVal;
			while (coolVal>1025) {
				drive(S,speed,0);
				coolVal = encoderVal + nMotorEncoder[DRIVE_NW];
				if (time1[T1]>4000) {
					endPgm();
				}
			}
		}
		else if (choiceArray[0]==0) {
			coolVal = encoderVal;
			while (coolVal>-7350) {
				drive(S,speed,0);
				coolVal = encoderVal + nMotorEncoder[DRIVE_NW];
				if (time1[T1]>4000) {
					endPgm();
				}
			}
		}

		if (choiceArray[2]==2) {

			motor[DRIVE_NW] = 12;
			motor[DRIVE_SE] = 12;
			motor[DRIVE_NE] = -90;
			motor[DRIVE_SW] = -90;
			wait1Msec(1550);
			halt();
			drive(E,50,2500);
			ClearTimer(T1);
			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<4500) {
				drive(N,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}
		else {

			motor[DRIVE_NW] = 12;
			motor[DRIVE_SE] = 12;
			motor[DRIVE_NE] = -90;
			motor[DRIVE_SW] = -90;
			wait1Msec(1550);



			ClearTimer(T1);
			while (onGrey(csfront) && onGrey(csback)) {
				drive(E,50,0);
				if (time1[T1]>4000) {
					endPgm();
				}
			}
			halt();

			lineUp();

			drive(E,80,150);
			drive(N,40,300);
			if (choiceArray[2]==1) {
				drive(E,80,150);
				while (onGrey(csfront) && onGrey(csback)) {
					drive(E,50,0);
				}
				lineUp();
				drive(E,80,400);
				while (onGrey(csfront) && onGrey(csback)) {
					drive(E,50,0);
				}

				lineUp();
				drive(W,80,200);
			}
			ClearTimer(T1);
			nMotorEncoder[DRIVE_NW]=0;
			while(nMotorEncoder[DRIVE_NW]<4000) {
				drive(N,100,0);
				if (time1[T1]>5000) {
					endPgm();
				}
			}
		}
	}
	halt();


}
